---
title: Go Testing Framework Rules
description: Guidelines for Go code in tests/act/ directory
globs:
  - "tests/act/**/*.go"
alwaysApply: false
---

# Go Testing Framework Rules

This directory contains Go tests using nektos/act to test GitHub Actions workflows.

## ⚠️ Work in Progress

The testing framework is currently **work in progress**. Do not write new tests unless explicitly requested by the user.

---

## Regenerating Mock Data

When making changes to any dummy test plugin in `tests/*` (except to the testing framework, itself in `tests/act`), you **must** regenerate the mock data in `tests/act/mockdata/`:

```bash
make mockdata
```

This ensures the pre-built plugin artifacts and ZIP packages used by tests stay in sync with the test plugins.

---

## Linting

Always run linting before finishing any changes:

```bash
make act-lint
```

Fix all reported issues before completing the task.

---

## Code Style

### Write Idiomatic Go

- Use short, clear variable names in limited scopes
- Prefer early returns over nested conditionals
- Use `errors.Join` for accumulating multiple errors
- Wrap errors with context using `fmt.Errorf("action: %w", err)`
- Use `//nolint:` comments sparingly and only with justification

### Error Handling

```go
// ✅ Correct - wrap errors with context
if err := doSomething(); err != nil {
    return fmt.Errorf("do something: %w", err)
}

// ✅ Correct - accumulate errors
var finalErr error
for _, item := range items {
    if err := process(item); err != nil {
        finalErr = errors.Join(finalErr, fmt.Errorf("process %q: %w", item, err))
    }
}
return finalErr

// ❌ Wrong - bare error return without context
if err := doSomething(); err != nil {
    return err
}
```

### Defer with Error Handling

When deferring Close() on resources that might fail:

```go
func readConfig(path string) (cfg Config, err error) {
    f, err := os.Open(path)
    if err != nil {
        return Config{}, fmt.Errorf("open config: %w", err)
    }
    defer func() {
        if closeErr := f.Close(); closeErr != nil && err == nil {
            err = closeErr
        }
    }()
    // ... use f
}
```

### Functional Options Pattern

Use functional options for configurable constructors:

```go
// Option type
type RunnerOption func(r *Runner)

// Option functions
func WithVerbose(verbose bool) RunnerOption {
    return func(r *Runner) {
        r.Verbose = verbose
    }
}

// Constructor using options
func NewRunner(t *testing.T, opts ...RunnerOption) (*Runner, error) {
    r := &Runner{t: t}
    for _, opt := range opts {
        opt(r)
    }
    return r, nil
}
```

---

## Testing with testify

Use `github.com/stretchr/testify` for assertions. Import `require` for assertions that should stop the test on failure:

```go
import (
    "testing"
    "github.com/stretchr/testify/require"
)

func TestSomething(t *testing.T) {
    result, err := DoSomething()
    require.NoError(t, err)
    require.Equal(t, expected, result)
    require.True(t, condition, "descriptive message")
}
```

### Test Structure

Use table-driven tests for multiple test cases:

```go
func TestFeature(t *testing.T) {
    type testCase struct {
        name     string
        input    string
        expected string
    }

    for _, tc := range []testCase{
        {
            name:     "basic case",
            input:    "hello",
            expected: "HELLO",
        },
        {
            name:     "empty input",
            input:    "",
            expected: "",
        },
    } {
        t.Run(tc.name, func(t *testing.T) {
            t.Parallel()
            result := Transform(tc.input)
            require.Equal(t, tc.expected, result)
        })
    }
}
```

### Parallel Tests

Run independent tests in parallel for faster execution:

```go
t.Run(tc.name, func(t *testing.T) {
    t.Parallel()
    // test code
})
```

### Cleanup

Use `t.Cleanup` for resource cleanup:

```go
artifact, err := runner.ArtifactsStorage.GetFolder(runID, name)
require.NoError(t, err)
t.Cleanup(func() { require.NoError(t, artifact.Close()) })
```

---

## Package Organization

### `internal/act/`
Core act runner functionality:
- `act.go` — Main Runner type and execution logic
- `artifacts.go` — Artifacts storage handling
- `gcs.go` — GCS mock storage
- `workflows.go` — Workflow file management

### `internal/workflow/`
Workflow definition types:
- `workflow.go` — Base workflow types (Job, Step, etc.) and helper functions (`Input`, `SetJobInput`, `PCIWFBaseRef` constant)
- `testing.go` — TestingWorkflow for test-specific workflows and TestingWorkflowOption functions
- `mock.go` — Mocking utilities (GCS, Vault, Argo Workflows)

### `internal/workflow/ci/`
CI workflow testing helpers:
- `ci.go` — `ci.Workflow` type and `ci.NewWorkflow()` constructor for testing CI workflows
- `mock.go` — CI-specific mocking utilities (workflow context)

### `internal/workflow/cd/`
CD workflow testing helpers:
- `cd.go` — `cd.Workflow` type and `cd.NewWorkflow()` constructor for testing CD workflows

### Main Package (`tests/act/`)
- `main_test.go` — Test utilities and TestMain setup
- `main_*_test.go` — Actual test files by category

---

## Workflow Testing Patterns

### Creating a CI Test Workflow

Use `ci.NewWorkflow()` with `ci.WorkflowInputs` struct to configure the workflow:

```go
wf, err := ci.NewWorkflow(
    ci.WithWorkflowInputs(ci.WorkflowInputs{
        PluginDirectory:     workflow.Input(filepath.Join("tests", "simple-frontend")),
        DistArtifactsPrefix: workflow.Input("simple-frontend-"),
        RunPlaywright:       workflow.Input(false),
    }),
)
require.NoError(t, err)
```

The `workflow.Input()` helper creates a pointer to a value, avoiding the need to write `&value` everywhere.

### Creating a CD Test Workflow

Use `cd.NewWorkflow()` with `cd.WorkflowInputs` struct:

```go
wf, err := cd.NewWorkflow(
    cd.WithWorkflowInputs(cd.WorkflowInputs{
        Environment:     workflow.Input("dev"),
        Branch:          workflow.Input("main"),
        PluginDirectory: workflow.Input("plugins/my-plugin"),
    }),
)
require.NoError(t, err)
```

### Workflow Structure

CI and CD workflows have a nested structure:
- **CI Workflow**: Parent workflow calls a child CI workflow (from `ci.yml`)
- **CD Workflow**: Parent workflow calls a CD child workflow (from `cd.yml`), which in turn calls a CI grandchild workflow

Access nested workflows using:
- `wf.CIWorkflow()` — Get the CI child workflow
- `wf.CDWorkflow()` — Get the CD child workflow (CD workflows only)
- `wf.CIWorkflow()` on CD workflows — Get the CI grandchild workflow

### Running a Workflow

```go
runner, err := act.NewRunner(t)
require.NoError(t, err)

result, err := runner.Run(wf, act.NewPushEventPayload("main"))
require.NoError(t, err)
require.True(t, result.Success, "workflow should succeed")
```

### Asserting on Outputs

```go
output, ok := result.Outputs.Get("job-id", "step-id", "output-name")
require.True(t, ok, "output should be present")
require.Equal(t, expectedValue, output)
```

### Checking Artifacts

```go
runID, err := result.GetTestingWorkflowRunID()
require.NoError(t, err)

artifacts, err := runner.ArtifactsStorage.GetFolder(runID, "artifact-name")
require.NoError(t, err)
t.Cleanup(func() { require.NoError(t, artifacts.Close()) })

err = checkFilesExist(artifacts.Fs, []string{"expected-file.txt"})
require.NoError(t, err)
```

### Mutating Workflows

Use workflow mutators to apply `TestingWorkflowOption` functions to nested workflows:

```go
wf, err := ci.NewWorkflow(
    ci.WithWorkflowInputs(ci.WorkflowInputs{
        PluginDirectory: workflow.Input("tests/simple-frontend"),
    }),
    // Mutate the testing workflow (parent)
    ci.MutateTestingWorkflow().With(
        workflow.WithPullRequestTargetTrigger([]string{"main"}),
    ),
    // Mutate the CI child workflow
    ci.MutateCIWorkflow().With(
        workflow.WithOnlyOneJob(t, "test-and-build"),
        workflow.WithRemoveAllStepsAfter(t, "test-and-build", "workflow-context"),
    ),
)
```

### Mocking Steps and Actions

In tests, you can mock services such as GCS, Vault, Argo, etc.

For example, use a mock GCS in a CI workflow, use `ci.MutateCIWorkflow().With(workflow.WithMockedGCS(t))`:

```go
wf, err := ci.NewWorkflow(
    // CI workflow custom inputs here
    ci.WithWorkflowInputs(ci.WorkflowInputs{
        // ...
    }),

    // Mock a trusted context to enable GCS upload
    ci.WithMockedWorkflowContext(t, ci.Context{
        IsTrusted: true,
    }),

    ci.MutateCIWorkflow().With(
        // Mock all GCS access
        workflow.WithMockedGCS(t),

        // No-op steps that are normally executed in a trusted context
        // but are not relevant for this test and would error out otherwise.
        workflow.WithNoOpStep(t, "test-and-build", "get-secrets"),
        workflow.WithNoOpStep(t, "test-and-build", "generate-github-token"),
    ),
)
```

When creating new mocks, you often have to use `MockAllStepsUsingAction` to mock
specific actions across all steps in a workflow:

```go
// Mock all GCS upload steps
err := wf.CIWorkflow().MockAllStepsUsingAction(workflow.GCSUploadAction, func(step workflow.Step) (workflow.Step, error) {
    return workflow.MockGCSUploadStep(step)
})
require.NoError(t, err)

// Mock all Vault secrets steps
err := wf.CDWorkflow().MockAllStepsUsingAction(workflow.VaultSecretsAction, func(step workflow.Step) (workflow.Step, error) {
    return workflow.MockVaultSecretsStep(step, workflow.VaultSecrets{
        "GCOM_PUBLISH_TOKEN_DEV": "mock-token",
    })
})
require.NoError(t, err)
```

---

## Type Definitions

### Use Composite Literals

```go
// ✅ Correct
step := workflow.Step{
    Name:  "Build",
    Run:   "go build ./...",
    Shell: "bash",
}

// ✅ Correct - using Commands helper for multi-line scripts
step := workflow.Step{
    Name: "Build",
    Run: workflow.Commands{
        "echo 'Building...'",
        "go build ./...",
        "echo 'Done'",
    }.String(),
    Shell: "bash",
}
```

### Helper Functions

Use `workflow.Input()` to create pointers for optional values:

```go
// ✅ Correct - using Input helper
wf, err := ci.NewWorkflow(
    ci.WithWorkflowInputs(ci.WorkflowInputs{
        PluginDirectory: workflow.Input("plugins/my-plugin"),
        RunPlaywright:    workflow.Input(false),
        // Optional fields can be nil
        PluginValidatorConfig: nil,
    }),
)

// ❌ Wrong - manual pointer creation
wf, err := ci.NewWorkflow(
    ci.WithWorkflowInputs(ci.WorkflowInputs{
        PluginDirectory: &[]string{"plugins/my-plugin"}[0], // awkward
    }),
)
```

Use `workflow.SetJobInput()` to safely set job inputs (handles nil pointers correctly):

```go
job := wf.BaseWorkflow.Jobs["ci"]
workflow.SetJobInput(job, "plugin-directory", inputs.PluginDirectory)
```

When adding new inputs to any of the testing workflows (`tests/act/internal/workflow/ci/ci.go` and `tests/act/internal/workflow/ci/cd.go`):

1. Add a pointer field (e.g.: `*string`, `*int`, etc) to the `WorkflowInputs` struct. The pointer is needed to handle nil (empty) values
2. Add a call to `workflow.SetJobInput` in `WithWorkflowInputs`
3. When constructing `WorkflowInputs` in tests, use `workflow.Input` to retrieve a pointer to the input value: `workflow.Input("bar")`

```go
// WorkflowInputs are the inputs for the CI workflow.
// They are used to customize the CI workflow.
type WorkflowInputs struct {
	// existing inputs...
    ExistingInput *string

    // 1. add a new pointer field to the struct
	MyInput       *string
}

// WithWorkflowInputs sets the inputs for the CI workflow.
func WithWorkflowInputs(inputs WorkflowInputs) WorkflowOption {
	return func(w *Workflow) {
		job := w.BaseWorkflow.Jobs["ci"]
        // existing inputs...
        workflow.SetJobInput(job, "existing-input", inputs.ExistingInput)

        // 2. add a call to workflow.SetJobInput
		workflow.SetJobInput(job, "my-input", inputs.MyInput)
	}
}
```

```go
ci.WithWorkflowInputs(ci.WorkflowInputs{
    ExistingInput: workflow.Input("foo"),
    // 3. In the test file, use it like this
    MyInput:       workflow.Input("bar"),
}),
```

### Maps and Slices

Initialize maps and slices with appropriate capacity when size is known:

```go
// ✅ Correct - known size
files := make(map[string]struct{}, len(expected))
results := make([]string, 0, len(items))

// ✅ Correct - unknown size, use nil
var results []string
for _, item := range items {
    if shouldInclude(item) {
        results = append(results, item)
    }
}
```

---

## Documentation

- Add package-level documentation for all packages
- Document exported types and functions
- Use Go doc conventions (start with the name being documented)

```go
// Package workflow contains types and functions to define GitHub Actions workflows.
// It provides a way to programmatically create workflows in a type-safe manner.
package workflow

// Runner is a test runner that executes GitHub Actions workflows using act.
type Runner struct {
    // ...
}

// NewRunner creates a new Runner instance.
// It requires act and gh CLI tools to be available in PATH.
func NewRunner(t *testing.T, opts ...RunnerOption) (*Runner, error) {
    // ...
}
```

---

## Dependencies

Current dependencies (from `go.mod`):
- `github.com/stretchr/testify` — Testing assertions
- `github.com/goccy/go-yaml` — YAML parsing/marshaling
- `github.com/google/uuid` — UUID generation
- `github.com/spf13/afero` — Filesystem abstraction for testing

When adding new dependencies, prefer well-maintained, minimal libraries.
