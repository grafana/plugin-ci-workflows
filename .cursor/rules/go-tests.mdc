---
title: Go Testing Framework Rules
description: Guidelines for Go code in tests/act/ directory
globs:
  - "tests/act/**/*.go"
alwaysApply: false
---

# Go Testing Framework Rules

This directory contains Go tests using nektos/act to test GitHub Actions workflows.

## ⚠️ Work in Progress

The testing framework is currently **work in progress**. Do not write new tests unless explicitly requested by the user.

---

## Regenerating Mock Data

When making changes to any dummy test plugin in `tests/*` (except to the testing framework, itself in `tests/act`), you **must** regenerate the mock data in `tests/act/mockdata/`:

```bash
make mockdata
```

This ensures the pre-built plugin artifacts and ZIP packages used by tests stay in sync with the test plugins.

---

## Linting

Always run linting before finishing any changes:

```bash
make act-lint
```

Fix all reported issues before completing the task.

---

## Code Style

### Write Idiomatic Go

- Use short, clear variable names in limited scopes
- Prefer early returns over nested conditionals
- Use `errors.Join` for accumulating multiple errors
- Wrap errors with context using `fmt.Errorf("action: %w", err)`
- Use `//nolint:` comments sparingly and only with justification

### Error Handling

```go
// ✅ Correct - wrap errors with context
if err := doSomething(); err != nil {
    return fmt.Errorf("do something: %w", err)
}

// ✅ Correct - accumulate errors
var finalErr error
for _, item := range items {
    if err := process(item); err != nil {
        finalErr = errors.Join(finalErr, fmt.Errorf("process %q: %w", item, err))
    }
}
return finalErr

// ❌ Wrong - bare error return without context
if err := doSomething(); err != nil {
    return err
}
```

### Defer with Error Handling

When deferring Close() on resources that might fail:

```go
func readConfig(path string) (cfg Config, err error) {
    f, err := os.Open(path)
    if err != nil {
        return Config{}, fmt.Errorf("open config: %w", err)
    }
    defer func() {
        if closeErr := f.Close(); closeErr != nil && err == nil {
            err = closeErr
        }
    }()
    // ... use f
}
```

### Functional Options Pattern

Use functional options for configurable constructors:

```go
// Option type
type RunnerOption func(r *Runner)

// Option functions
func WithVerbose(verbose bool) RunnerOption {
    return func(r *Runner) {
        r.Verbose = verbose
    }
}

// Constructor using options
func NewRunner(t *testing.T, opts ...RunnerOption) (*Runner, error) {
    r := &Runner{t: t}
    for _, opt := range opts {
        opt(r)
    }
    return r, nil
}
```

---

## Testing with testify

Use `github.com/stretchr/testify` for assertions. Import `require` for assertions that should stop the test on failure:

```go
import (
    "testing"
    "github.com/stretchr/testify/require"
)

func TestSomething(t *testing.T) {
    result, err := DoSomething()
    require.NoError(t, err)
    require.Equal(t, expected, result)
    require.True(t, condition, "descriptive message")
}
```

### Test Structure

Use table-driven tests for multiple test cases:

```go
func TestFeature(t *testing.T) {
    type testCase struct {
        name     string
        input    string
        expected string
    }

    for _, tc := range []testCase{
        {
            name:     "basic case",
            input:    "hello",
            expected: "HELLO",
        },
        {
            name:     "empty input",
            input:    "",
            expected: "",
        },
    } {
        t.Run(tc.name, func(t *testing.T) {
            t.Parallel()
            result := Transform(tc.input)
            require.Equal(t, tc.expected, result)
        })
    }
}
```

### Parallel Tests

Run independent tests in parallel for faster execution:

```go
t.Run(tc.name, func(t *testing.T) {
    t.Parallel()
    // test code
})
```

### Cleanup

Use `t.Cleanup` for resource cleanup:

```go
artifact, err := runner.ArtifactsStorage.GetFolder(runID, name)
require.NoError(t, err)
t.Cleanup(func() { require.NoError(t, artifact.Close()) })
```

---

## Package Organization

### `internal/act/`
Core act runner functionality:
- `act.go` — Main Runner type and execution logic
- `artifacts.go` — Artifacts storage handling
- `gcs.go` — GCS mock storage
- `workflows.go` — Workflow file management

### `internal/workflow/`
Workflow definition types:
- `workflow.go` — Base workflow types (Job, Step, etc.)
- `testing.go` — TestingWorkflow for test-specific workflows
- `ci.go` — CI workflow helpers
- `mock.go` — Mocking utilities

### Main Package (`tests/act/`)
- `main_test.go` — Test utilities and TestMain setup
- `main_*_test.go` — Actual test files by category

---

## Workflow Testing Patterns

### Using Temporary Plugin Directories

**Always** use `act.CopyPluginToTemp` to copy plugin source directories to a temporary folder before running tests. This prevents the `--bind` mount from leaving leftover files (`dist/`, `node_modules/`, etc.) in the repository after tests run.

```go
// ✅ Correct - copy plugin to temp directory first
tempDir, err := act.CopyPluginToTemp(t, "simple-frontend")
require.NoError(t, err)

wf, err := workflow.NewSimpleCI(
    workflow.WithPluginDirectoryInput(tempDir),
    workflow.WithDistArtifactPrefixInput("simple-frontend-"),
)

// ❌ Wrong - using source directory directly leaves leftover files
wf, err := workflow.NewSimpleCI(
    workflow.WithPluginDirectoryInput(filepath.Join("tests", "simple-frontend")),
    workflow.WithDistArtifactPrefixInput("simple-frontend-"),
)
```

The `CopyPluginToTemp` function:
- Copies the plugin from `tests/{sourceDir}` to a unique temp folder in `.act-test-plugins/` (inside the repo root)
- Automatically skips `node_modules/`, `dist/`, and `dist-artifacts/` directories
- Registers `t.Cleanup()` to remove the temp folder after the test
- Returns a **relative** path (from repo root) for use with `workflow.WithPluginDirectoryInput()`

To manually clean up all temp plugin directories:

```bash
make clean-act-test-plugins
```

### Creating a Test Workflow

```go
// First copy the plugin to a temp directory
tempDir, err := act.CopyPluginToTemp(t, "simple-frontend")
require.NoError(t, err)

wf, err := workflow.NewSimpleCI(
    workflow.WithPluginDirectoryInput(tempDir),
    workflow.WithDistArtifactPrefixInput("simple-frontend-"),
    workflow.WithPlaywrightInput(false),
)
require.NoError(t, err)
```

### Running a Workflow

```go
runner, err := act.NewRunner(t)
require.NoError(t, err)

result, err := runner.Run(wf, act.NewPushEventPayload("main"))
require.NoError(t, err)
require.True(t, result.Success, "workflow should succeed")
```

### Asserting on Outputs

```go
output, ok := result.Outputs.Get("job-id", "step-id", "output-name")
require.True(t, ok, "output should be present")
require.Equal(t, expectedValue, output)
```

### Checking Artifacts

```go
runID, err := result.GetTestingWorkflowRunID()
require.NoError(t, err)

artifacts, err := runner.ArtifactsStorage.GetFolder(runID, "artifact-name")
require.NoError(t, err)
t.Cleanup(func() { require.NoError(t, artifacts.Close()) })

err = checkFilesExist(artifacts.Fs, []string{"expected-file.txt"})
require.NoError(t, err)
```

---

## Type Definitions

### Use Composite Literals

```go
// ✅ Correct
step := workflow.Step{
    Name:  "Build",
    Run:   "go build ./...",
    Shell: "bash",
}

// ✅ Correct - using Commands helper for multi-line scripts
step := workflow.Step{
    Name: "Build",
    Run: workflow.Commands{
        "echo 'Building...'",
        "go build ./...",
        "echo 'Done'",
    }.String(),
    Shell: "bash",
}
```

### Maps and Slices

Initialize maps and slices with appropriate capacity when size is known:

```go
// ✅ Correct - known size
files := make(map[string]struct{}, len(expected))
results := make([]string, 0, len(items))

// ✅ Correct - unknown size, use nil
var results []string
for _, item := range items {
    if shouldInclude(item) {
        results = append(results, item)
    }
}
```

---

## Documentation

- Add package-level documentation for all packages
- Document exported types and functions
- Use Go doc conventions (start with the name being documented)

```go
// Package workflow contains types and functions to define GitHub Actions workflows.
// It provides a way to programmatically create workflows in a type-safe manner.
package workflow

// Runner is a test runner that executes GitHub Actions workflows using act.
type Runner struct {
    // ...
}

// NewRunner creates a new Runner instance.
// It requires act and gh CLI tools to be available in PATH.
func NewRunner(t *testing.T, opts ...RunnerOption) (*Runner, error) {
    // ...
}
```

---

## Dependencies

Current dependencies (from `go.mod`):
- `github.com/stretchr/testify` — Testing assertions
- `github.com/goccy/go-yaml` — YAML parsing/marshaling
- `github.com/google/uuid` — UUID generation
- `github.com/spf13/afero` — Filesystem abstraction for testing

When adding new dependencies, prefer well-maintained, minimal libraries.
