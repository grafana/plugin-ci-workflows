---
title: Go Testing Framework Rules
description: Guidelines for Go code in tests/act/ directory
globs:
  - "tests/act/**/*.go"
alwaysApply: false
---

# Go Testing Framework Rules

This directory contains Go tests using nektos/act to test GitHub Actions workflows.

## ⚠️ Work in Progress

The testing framework is currently **work in progress**. Do not write new tests unless explicitly requested by the user.

---

## Regenerating Mock Data

When making changes to any dummy test plugin in `tests/*` (except to the testing framework, itself in `tests/act`), you **must** regenerate the mock data in `tests/act/mockdata/`:

```bash
make mockdata
```

This ensures the pre-built plugin artifacts and ZIP packages used by tests stay in sync with the test plugins.

---

## Linting

Always run linting before finishing any changes:

```bash
make act-lint
```

Fix all reported issues before completing the task.

---

## Code Style

### Write Idiomatic Go

- Use short, clear variable names in limited scopes
- Prefer early returns over nested conditionals
- Use `errors.Join` for accumulating multiple errors
- Wrap errors with context using `fmt.Errorf("action: %w", err)`
- Use `//nolint:` comments sparingly and only with justification

### Error Handling

```go
// ✅ Correct - wrap errors with context
if err := doSomething(); err != nil {
    return fmt.Errorf("do something: %w", err)
}

// ✅ Correct - accumulate errors
var finalErr error
for _, item := range items {
    if err := process(item); err != nil {
        finalErr = errors.Join(finalErr, fmt.Errorf("process %q: %w", item, err))
    }
}
return finalErr

// ❌ Wrong - bare error return without context
if err := doSomething(); err != nil {
    return err
}
```

### Defer with Error Handling

When deferring Close() on resources that might fail:

```go
func readConfig(path string) (cfg Config, err error) {
    f, err := os.Open(path)
    if err != nil {
        return Config{}, fmt.Errorf("open config: %w", err)
    }
    defer func() {
        if closeErr := f.Close(); closeErr != nil && err == nil {
            err = closeErr
        }
    }()
    // ... use f
}
```

### Functional Options Pattern

Use functional options for configurable constructors:

```go
// Option type
type RunnerOption func(r *Runner)

// Option functions
func WithVerbose(verbose bool) RunnerOption {
    return func(r *Runner) {
        r.Verbose = verbose
    }
}

// Constructor using options
func NewRunner(t *testing.T, opts ...RunnerOption) (*Runner, error) {
    r := &Runner{t: t}
    for _, opt := range opts {
        opt(r)
    }
    return r, nil
}
```

---

## Testing with testify

Use `github.com/stretchr/testify` for assertions. Import `require` for assertions that should stop the test on failure:

```go
import (
    "testing"
    "github.com/stretchr/testify/require"
)

func TestSomething(t *testing.T) {
    result, err := DoSomething()
    require.NoError(t, err)
    require.Equal(t, expected, result)
    require.True(t, condition, "descriptive message")
}
```

### Test Structure

Use table-driven tests for multiple test cases:

```go
func TestFeature(t *testing.T) {
    type testCase struct {
        name     string
        input    string
        expected string
    }

    for _, tc := range []testCase{
        {
            name:     "basic case",
            input:    "hello",
            expected: "HELLO",
        },
        {
            name:     "empty input",
            input:    "",
            expected: "",
        },
    } {
        t.Run(tc.name, func(t *testing.T) {
            t.Parallel()
            result := Transform(tc.input)
            require.Equal(t, tc.expected, result)
        })
    }
}
```

### Parallel Tests

Run independent tests in parallel for faster execution:

```go
t.Run(tc.name, func(t *testing.T) {
    t.Parallel()
    // test code
})
```

### Cleanup

Use `t.Cleanup` for resource cleanup:

```go
artifact, err := runner.ArtifactsStorage.GetFolder(runID, name)
require.NoError(t, err)
t.Cleanup(func() { require.NoError(t, artifact.Close()) })
```

---

## Package Organization

### `internal/act/`
Core act runner functionality:
- `act.go` — Main Runner type and execution logic
- `artifacts.go` — Artifacts storage handling
- `gcs.go` — GCS mock storage
- `gcom.go` — GCOM API mock server for CD workflow testing
- `workflows.go` — Workflow file management

### `internal/workflow/`
Workflow definition types:
- `workflow.go` — Base workflow types (Job, Step, etc.) and helper functions (`Input`, `SetJobInput`, `PCIWFBaseRef` constant)
- `testing.go` — TestingWorkflow for test-specific workflows and TestingWorkflowOption functions
- `mock.go` — Mocking utilities (GCS, Vault, Argo Workflows, GitHub App Token)

### `internal/workflow/ci/`
CI workflow testing helpers:
- `ci.go` — `ci.Workflow` type and `ci.NewWorkflow()` constructor for testing CI workflows
- `mock.go` — CI-specific mocking utilities (workflow context)

### `internal/workflow/cd/`
CD workflow testing helpers:
- `cd.go` — `cd.Workflow` type and `cd.NewWorkflow()` constructor for testing CD workflows

### Main Package (`tests/act/`)
- `main_test.go` — Test utilities and TestMain setup
- `main_*_test.go` — Actual test files by category

---

## Workflow Testing Patterns

### Creating a CI Test Workflow

Use `ci.NewWorkflow()` with `ci.WorkflowInputs` struct to configure the workflow:

```go
wf, err := ci.NewWorkflow(
    ci.WithWorkflowInputs(ci.WorkflowInputs{
        PluginDirectory:     workflow.Input(filepath.Join("tests", "simple-frontend")),
        DistArtifactsPrefix: workflow.Input("simple-frontend-"),
        RunPlaywright:       workflow.Input(false),
    }),
)
require.NoError(t, err)
```

The `workflow.Input()` helper creates a pointer to a value, avoiding the need to write `&value` everywhere.

### Creating a CD Test Workflow

Use `cd.NewWorkflow()` with `cd.WorkflowInputs` struct:

```go
wf, err := cd.NewWorkflow(
    cd.WithWorkflowInputs(cd.WorkflowInputs{
        CI: ci.WorkflowInputs{
            PluginDirectory:     workflow.Input(filepath.Join("tests", "simple-backend")),
            DistArtifactsPrefix: workflow.Input("simple-backend-"),
            Testing:             workflow.Input(false),
            AllowUnsigned:       workflow.Input(true),
        },
        Environment:           workflow.Input("dev"),
        DisableDocsPublishing: workflow.Input(true),
        DisableGitHubRelease:  workflow.Input(true),
    }),
)
require.NoError(t, err)
```

CD workflows embed CI workflow inputs via the `CI` field in `cd.WorkflowInputs`.

### Workflow Structure

CI and CD workflows have a nested structure:
- **CI Workflow**: Parent workflow calls a child CI workflow (from `ci.yml`)
- **CD Workflow**: Parent workflow calls a CD child workflow (from `cd.yml`), which in turn calls a CI grandchild workflow

Access nested workflows using:
- `wf.CIWorkflow()` — Get the CI child workflow
- `wf.CDWorkflow()` — Get the CD child workflow (CD workflows only)
- `wf.CIWorkflow()` on CD workflows — Get the CI grandchild workflow

### Running a Workflow

```go
runner, err := act.NewRunner(t)
require.NoError(t, err)

result, err := runner.Run(wf, act.NewPushEventPayload("main"))
require.NoError(t, err)
require.True(t, result.Success, "workflow should succeed")
```

### Asserting on Outputs

```go
output, ok := result.Outputs.Get("job-id", "step-id", "output-name")
require.True(t, ok, "output should be present")
require.Equal(t, expectedValue, output)
```

### Checking Artifacts

```go
runID, err := result.GetTestingWorkflowRunID()
require.NoError(t, err)

artifacts, err := runner.ArtifactsStorage.GetFolder(runID, "artifact-name")
require.NoError(t, err)
t.Cleanup(func() { require.NoError(t, artifacts.Close()) })

err = checkFilesExist(artifacts.Fs, []string{"expected-file.txt"})
require.NoError(t, err)
```

### Mutating Workflows

Use workflow mutators to apply `TestingWorkflowOption` functions to nested workflows:

```go
wf, err := ci.NewWorkflow(
    ci.WithWorkflowInputs(ci.WorkflowInputs{
        PluginDirectory: workflow.Input("tests/simple-frontend"),
    }),
    // Mutate the testing workflow (parent)
    ci.MutateTestingWorkflow().With(
        workflow.WithPullRequestTargetTrigger([]string{"main"}),
    ),
    // Mutate the CI child workflow
    ci.MutateCIWorkflow().With(
        workflow.WithOnlyOneJob(t, "test-and-build"),
        workflow.WithRemoveAllStepsAfter(t, "test-and-build", "workflow-context"),
    ),
)
```

For CD workflows, additional mutators are available:

```go
wf, err := cd.NewWorkflow(
    cd.WithWorkflowInputs(cd.WorkflowInputs{...}),

    // Mutate the CD child workflow
    cd.MutateCDWorkflow().With(
        workflow.WithNoOpStep(t, "upload-to-gcs-release", "gcloud-sdk"),
        workflow.WithMatrix("publish-to-catalog", map[string][]string{
            "environment": {"dev"},
        }),
    ),

    // Mutate the CI grandchild workflow
    cd.MutateCIWorkflow().With(
        workflow.WithMockedGCS(t),
    ),

    // Mutate all workflows (parent, CD child, CI grandchild)
    cd.MutateAllWorkflows().With(
        workflow.WithMockedVault(t, mockVault),
        workflow.WithMockedGitHubAppToken(t),
    ),
)
```

### Mocking Steps and Actions

In tests, you can mock services such as GCS, Vault, GCOM, Argo, GitHub App Token, etc.

**Mock GCS in a CI workflow:**

```go
wf, err := ci.NewWorkflow(
    ci.WithWorkflowInputs(ci.WorkflowInputs{...}),

    // Mock a trusted context to enable GCS upload
    ci.WithMockedWorkflowContext(t, ci.Context{IsTrusted: true}),

    ci.MutateCIWorkflow().With(
        // Mock all GCS access
        workflow.WithMockedGCS(t),

        // No-op steps that are normally executed in a trusted context
        workflow.WithNoOpStep(t, "test-and-build", "get-secrets"),
        workflow.WithNoOpStep(t, "test-and-build", "generate-github-token"),
    ),
)
```

**Mock GCOM API in a CD workflow:**

The runner provides a built-in GCOM mock server accessible via `runner.GCOM`:

```go
runner, err := act.NewRunner(t)
require.NoError(t, err)

// Register mock handlers for GCOM API endpoints
runner.GCOM.HandleFunc("GET /api/plugins/{pluginID}", func(w http.ResponseWriter, r *http.Request) {
    w.WriteHeader(http.StatusOK)
    json.NewEncoder(w).Encode(map[string]any{
        "id":     1,
        "status": "active",
        "slug":   "my-plugin",
    })
})

runner.GCOM.HandleFunc("POST /api/plugins", func(w http.ResponseWriter, r *http.Request) {
    // Assert request body, headers, etc.
    var body map[string]any
    require.NoError(t, json.NewDecoder(r.Body).Decode(&body))
    require.Equal(t, []any{"universal"}, body["scopes"])

    w.WriteHeader(http.StatusOK)
    json.NewEncoder(w).Encode(map[string]any{
        "plugin": map[string]any{"id": 1337},
    })
})

wf, err := cd.NewWorkflow(
    cd.WithWorkflowInputs(cd.WorkflowInputs{...}),
    // Use the mock GCOM server
    cd.WithMockedGCOM(runner.GCOM),
)
```

**Mock Vault secrets:**

```go
mockVault := workflow.VaultSecrets{
    DefaultValue: newPointer(""), // Use empty string for undefined secrets
    CommonSecrets: map[string]string{
        "plugins/gcom-publish-token:dev":  "mock-dev-token",
        "plugins/gcom-publish-token:ops":  "mock-ops-token",
        "plugins/gcom-publish-token:prod": "mock-prod-token",
    },
}

wf, err := cd.NewWorkflow(
    cd.MutateAllWorkflows().With(
        workflow.WithMockedVault(t, mockVault),
    ),
)
```

**Replace a step with mock outputs:**

```go
cd.MutateCDWorkflow().With(
    workflow.WithReplacedStep(
        t, "upload-to-gcs-release", "gcs_artifacts_exist",
        workflow.MockOutputsStep(map[string]string{
            "gcs_artifacts_exist": "false",
        }),
    ),
)
```

**Override a job's matrix strategy:**

```go
// Useful when act doesn't support dynamic matrices
cd.MutateCDWorkflow().With(
    workflow.WithMatrix("publish-to-catalog", map[string][]string{
        "environment": {"dev"},
    }),
    workflow.WithMatrix("upload-to-gcs-release", map[string][]string{
        "platform": {"linux", "darwin", "windows", "any"},
    }),
)
```

When creating new mocks, use `MockAllStepsUsingAction` to mock specific actions across all steps:

```go
// Mock all GCS upload steps
err := wf.CIWorkflow().MockAllStepsUsingAction(workflow.GCSUploadAction, func(step workflow.Step) (workflow.Step, error) {
    return workflow.MockGCSUploadStep(step)
})
require.NoError(t, err)

// Mock all Vault secrets steps
err := wf.CDWorkflow().MockAllStepsUsingAction(workflow.VaultSecretsAction, func(step workflow.Step) (workflow.Step, error) {
    return workflow.MockVaultSecretsStep(step, mockVault)
})
require.NoError(t, err)
```

---

## Type Definitions

### Use Composite Literals

```go
// ✅ Correct
step := workflow.Step{
    Name:  "Build",
    Run:   "go build ./...",
    Shell: "bash",
}

// ✅ Correct - using Commands helper for multi-line scripts
step := workflow.Step{
    Name: "Build",
    Run: workflow.Commands{
        "echo 'Building...'",
        "go build ./...",
        "echo 'Done'",
    }.String(),
    Shell: "bash",
}
```

### Helper Functions

Use `workflow.Input()` to create pointers for optional values:

```go
// ✅ Correct - using Input helper
wf, err := ci.NewWorkflow(
    ci.WithWorkflowInputs(ci.WorkflowInputs{
        PluginDirectory: workflow.Input("plugins/my-plugin"),
        RunPlaywright:    workflow.Input(false),
        // Optional fields can be nil
        PluginValidatorConfig: nil,
    }),
)

// ❌ Wrong - manual pointer creation
wf, err := ci.NewWorkflow(
    ci.WithWorkflowInputs(ci.WorkflowInputs{
        PluginDirectory: &[]string{"plugins/my-plugin"}[0], // awkward
    }),
)
```

Use `workflow.SetJobInput()` to safely set job inputs (handles nil pointers correctly):

```go
job := wf.BaseWorkflow.Jobs["ci"]
workflow.SetJobInput(job, "plugin-directory", inputs.PluginDirectory)
```

When adding new inputs to any of the testing workflows (`tests/act/internal/workflow/ci/ci.go` and `tests/act/internal/workflow/cd/cd.go`):

1. Add a pointer field (e.g.: `*string`, `*int`, etc) to the `WorkflowInputs` struct. The pointer is needed to handle nil (empty) values
2. Add a call to `workflow.SetJobInput` in `WithWorkflowInputs`
3. When constructing `WorkflowInputs` in tests, use `workflow.Input` to retrieve a pointer to the input value: `workflow.Input("bar")`

```go
// WorkflowInputs are the inputs for the CI workflow.
// They are used to customize the CI workflow.
type WorkflowInputs struct {
	// existing inputs...
    ExistingInput *string

    // 1. add a new pointer field to the struct
	MyInput       *string
}

// WithWorkflowInputs sets the inputs for the CI workflow.
func WithWorkflowInputs(inputs WorkflowInputs) WorkflowOption {
	return func(w *Workflow) {
		job := w.BaseWorkflow.Jobs["ci"]
        // existing inputs...
        workflow.SetJobInput(job, "existing-input", inputs.ExistingInput)

        // 2. add a call to workflow.SetJobInput
		workflow.SetJobInput(job, "my-input", inputs.MyInput)
	}
}
```

```go
ci.WithWorkflowInputs(ci.WorkflowInputs{
    ExistingInput: workflow.Input("foo"),
    // 3. In the test file, use it like this
    MyInput:       workflow.Input("bar"),
}),
```

### VaultSecrets Type

The `VaultSecrets` type allows defining mock secret values:

```go
type VaultSecrets struct {
    // CommonSecrets contains secrets referenced in 'common_secrets' input
    CommonSecrets map[string]string
    // RepoSecrets contains secrets referenced in 'repo_secrets' input
    RepoSecrets map[string]string
    // DefaultValue is used for undefined secrets (nil = error if secret not found)
    DefaultValue *string
}

// Example usage
mockVault := workflow.VaultSecrets{
    DefaultValue: newPointer(""), // Use empty string for undefined secrets
    CommonSecrets: map[string]string{
        "plugins/gcom-publish-token:dev":  "mock-dev-token",
        "plugins/gcom-publish-token:ops":  "mock-ops-token",
    },
}
```

### Maps and Slices

Initialize maps and slices with appropriate capacity when size is known:

```go
// ✅ Correct - known size
files := make(map[string]struct{}, len(expected))
results := make([]string, 0, len(items))

// ✅ Correct - unknown size, use nil
var results []string
for _, item := range items {
    if shouldInclude(item) {
        results = append(results, item)
    }
}
```

---

## Available Testing Options

### TestingWorkflowOption Functions

These options can be applied to any `TestingWorkflow` via mutators:

| Option | Description |
|--------|-------------|
| `WithOnlyOneJob(t, jobID)` | Keep only the specified job and its dependencies |
| `WithoutJob(jobID)` | Remove a job from the workflow |
| `WithNoOpStep(t, jobID, stepID)` | Replace a step with a no-op |
| `WithReplacedStep(t, jobID, stepID, step)` | Replace a step with a custom step |
| `WithRemoveAllStepsAfter(t, jobID, stepID)` | Remove all steps after the specified step |
| `WithMockedGCS(t)` | Mock all GCS upload/auth steps |
| `WithMockedVault(t, secrets)` | Mock Vault secrets steps |
| `WithMockedGitHubAppToken(t, token...)` | Mock GitHub App token creation |
| `WithMatrix(jobID, matrix)` | Override a job's matrix strategy |
| `WithPullRequestTargetTrigger(branches)` | Set pull_request_target trigger |

### CD-Specific Options

| Option | Description |
|--------|-------------|
| `cd.WithMockedGCOM(runner.GCOM)` | Use the mock GCOM server |
| `cd.WithMockedArgoWorkflows(t)` | Mock Argo Workflow trigger steps |
| `cd.WithCIOptions(opts...)` | Apply CI options to the CI grandchild workflow |

### Mock Step Helpers

| Function | Description |
|----------|-------------|
| `workflow.NoOpStep(originalStep)` | Create a no-op step preserving the name |
| `workflow.MockOutputsStep(outputs)` | Create a step that only sets outputs |
| `workflow.MockGCSUploadStep(step)` | Mock GCS upload to local filesystem |
| `workflow.MockVaultSecretsStep(step, secrets)` | Mock Vault secrets retrieval |
| `workflow.MockArgoWorkflowStep(step)` | Mock Argo Workflow trigger |
| `workflow.MockGitHubAppTokenStep(step, token)` | Mock GitHub App token creation |

---

## Documentation

- Add package-level documentation for all packages
- Document exported types and functions
- Use Go doc conventions (start with the name being documented)

```go
// Package workflow contains types and functions to define GitHub Actions workflows.
// It provides a way to programmatically create workflows in a type-safe manner.
package workflow

// Runner is a test runner that executes GitHub Actions workflows using act.
type Runner struct {
    // ...
}

// NewRunner creates a new Runner instance.
// It requires act and gh CLI tools to be available in PATH.
func NewRunner(t *testing.T, opts ...RunnerOption) (*Runner, error) {
    // ...
}
```

---

## Dependencies

Current dependencies (from `go.mod`):
- `github.com/stretchr/testify` — Testing assertions
- `github.com/goccy/go-yaml` — YAML parsing/marshaling
- `github.com/google/uuid` — UUID generation
- `github.com/spf13/afero` — Filesystem abstraction for testing

When adding new dependencies, prefer well-maintained, minimal libraries.
